/*
 * Created  by rbh, 27/02/15
 * Modified by nas, 18/12/16
 */

#include <sstream>
#include <fstream>
#include <iostream>
#include <cassert>
#include <cmath>

#include "xmlparser.h"
#include "route.h"



namespace GPXP
{
	const metres Route::granularity = 20;
	const Position Route::northPole = Position(90,0,0);

	//declarations has been made public to be used by all functions
	std::ostringstream oss;
	using std::endl;

	Route::Route(string source, bool isFileName)
	{
		using namespace XML_Parser;

		fileCheck(isFileName, source); //function to check files

		if (!constCheck(source, "abc"))
		{
			return;
		}

		if (!constCheck(source, "abc"))
		{
			return;
		}

		source = getElementContent(getElement(source, "rte"));

		if (constCheck(source, "hatimmm"))
		{
			routeName = getElementContent(getAndEraseElement(source, "name"));
			oss << endl << "route name is " << routeName;
		}

		if (!constCheck(source, "rtept"))
		{
			return;
		}

		string temp ;
				string lat = getElementAttribute(getAndEraseElement(source, "rtept"), "lat");
				string lon = getElementAttribute(getAndEraseElement(source, "rtept"), "lon");
				string ele = getElementContent(getElement(getAndEraseElement(source, "rtept"), "ele"));
				string name;


		Position currentPos(lat, lon, ele);
				addCurrPosition(currentPos, name);

		while (elementExists(source, "rtept"))
		{
			temp = getAndEraseElement(source, "rtept");
						lat = getElementAttribute(temp, "lat");
						lon = getElementAttribute(temp, "lon");
						ele = getElementContent(getElement(temp, "ele"));
			if (constCheck(temp,"name"))
			{
				name = getElementContent(getElement(temp, "name"));
			}

			else
			{
				name = "";
			}

			Position nextPos(lat, lon, ele);
			addNextPosition(currentPos, nextPos, name);
		}

		oss << endl << positions.size() << " positions added";
		calDistance();
		constStat(true);
		return;
	}

	bool Route::builtOk() const
	{
		return constructorSucceeded;
	}

	string Route::buildReport() const
	{
		/* Returns the report generated by the constructor, for debugging purposes.
		*/
		implementation(true);
		return constructorReport;
	}

	string Route::name() const
	{
		/* Returns the name of the Route, or "Unnamed Route" if nameless.
		*/
		implementation(false);
		return routeName.empty() ? "Unnamed Route" : routeName;
	}

	metres Route::totalLength() const
	{
		/* Computes and returns the total length of the Route; this is
		* the sum of the distances between the successive Positions of the Route.
		*/
		implementation(true);
		return routeLength;
	}

	metres Route::netLength() const
	{
		/* Returns the distance between the first and last points on the Route.
		*/
		implementation(true);

		const Position & start  = positions.front();
		const Position & finish = positions.back();

		metres deltaH = distanceBetween(start,finish);
		metres deltaV = start.getElevation() - finish.getElevation();

		return std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
	}

	metres Route::totalHeightGain() const
	{
		/* Returns the sum of all the positive (>0) height differences between points.
		*/
		implementation(false);
		return (0);
	}

	metres Route::netHeightGain() const
	{
		/* Returns the difference in elevation between the first and last points on the
		* Route.
		* Should be negative if there was a net height loss.
		*/
		implementation(false);
		return (0);
	}

	degrees Route::maxUphillGradient() const
	{
		/* Returns the maximum value of gradient between successive points on the Route.
		*/
		implementation(false);
		return (0);
	}

	degrees Route::maxDownhillGradient() const
	{
		/* Returns the minimum (most negative) value of gradient between successive points
		* on the Route.
		*/
		implementation(false);
		return (0);
	}

	degrees Route::minLat() const
	{
		/* Returns the latitude of the most Southerly point on the Route.
		*/
		implementation(false);
		return (90.0);
	}

	degrees Route::maxLat() const
	{
		/* Returns the latitude of the most Northerly point on the Route.
		*/
		implementation(false);
		return (-90.0);
	}

	degrees Route::minLon() const
	{
		/* Returns the longitude of the most Westerly point on the Route.
		*/
		implementation(false);
		return (90.0);
	}

	degrees Route::maxLon() const
	{
		/* Returns the longitude of the most Easterly point on the Route.
		*/
		implementation(false);
		return (-90.0);
	}

	metres Route::minEle() const
	{
		/* Returns the elevation of the lowest point on the Route.
		*/
		implementation(false);
		return (4000);
	}

	metres Route::maxEle() const
	{
		/* Returns the elevation of the highest point on the Route.
		*/
		implementation(false);
		return (0);
	}

	unsigned int Route::timesVisited(const Position & pos) const
	{
		/* Returns the number of times that the Position is visited on the Route.
		*/
		implementation(false);
		return (0);
	}

	unsigned int Route::timesVisited(const string & nameTag) const
	{
		/* Returns the number of times that the Position with <name>nameTag</name>
		* is visited on the Route.  If nameTag == "", return 0.
		*/
		implementation(false);
		return (0);
	}

	unsigned int Route::numPositions() const
	{
		/* Returns the number of Positions in this Route.
		*/
		implementation(false);
		return (0);
	}

	string Route::nameOf(const Position & pos) const
	{
		/* Determine whether the Position occurs anywhere on the Route,
		* and if so whether it has a name at any of the occurrences;
		* return the name if it has one, or an empty string otherwise.
		*/
		implementation(false);
		return (string("not implemented"));
	}

	Position Route::positionOf(const string & nameTag) const
	{
		/* This function is the inverse of Route::nameOf().  It searches on the Route
		* for a point named nameTag.  If found, its Position is returned, else the
		* North Pole Position is returned.
		*/
		implementation(false);
		return (northPole);
	}

	const Position & Route::operator[](unsigned int idx) const
	{
		/* Provides access to the sequence of points that make up the Route.
		* Out-of-range access should return the North Pole Position.
		*/
		implementation(false);
		return (northPole);
	}

	bool Route::areSameLocation(const Position & p1, const Position & p2) const
	{
		/* Determines whether the 2 Positions parameters are less than "granularity" apart.
		*/
		implementation(true);
		return (distanceBetween(p1,p2) < granularity);
	}

	bool Route::append(const Position & pos, const string & name)
	{
		/*  Append the position to the end of the "positions" vector, unless
		*  it is close enough to the last Position to be considered the same
		*  location (see "areSameLocation()").  The routeLength is updated
		*  accordingly.
		*/
		implementation(true);
		Position prevPos = positions.back();
		if (areSameLocation(pos, prevPos))
		{
			return false;
		}
		else
		{
			metres deltaH = distanceBetween(pos,prevPos);
			metres deltaV = pos.getElevation() - prevPos.getElevation();
			routeLength += std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
			positions.push_back(pos);
			positionNames.push_back(name);

          return true;
		}
	}

	void Route::simplify(unsigned int overridingGranularity)
	{
		/* Simplify the Route by reducing the number of points: any point in
		* the Route that differs in distance from its predecessor by less than
		* the parameter is discarded.
		*/
		implementation(false);
	}

	void Route::implementation(bool implemented) const //function to check if it is implemented
	{
		assert(implemented);
	}

	bool Route::constCheck(string source, string type)
	{
		// Function to check if the element exists
		if (!XML_Parser::elementExists(source, type))
		{
			oss << std::endl << "no " << type << " tag";
			constStat(false);
			return false;
		}
		return true;
	}

	void Route::constStat(bool stat)
	{
		// Function to see the status of the constructor
		constructorReport = oss.str();
		constructorSucceeded = stat;
	}

	void Route::calDistance()
	{
		// Function to calculate the distance between pci1 and pci2
		routeLength = 0;
		vector<Position>::const_iterator pci1, pci2;
		pci1 = pci2 = positions.begin();
		++pci2;

		for (; pci2 != positions.end(); ++pci1, ++pci2)
		{
			metres delta1 = distanceBetween(*pci1, *pci2);
			metres delta2 = pci1->getElevation() - pci2->getElevation();
			routeLength += std::sqrt(std::pow(delta1, 2) + std::pow(delta2, 2));
		}
	}

	void Route::fileCheck(bool isFileName, std::string &source)
	{
		// Function to check the file
		if (isFileName)
		{
			string content, line;
			std::ifstream file(source);

			if (!file)
			{
				oss << endl << "error opening constructor source file " << source;
				constStat(false); //changed
				return;
			}

			oss << endl << "source file " << source << " opened okay";

			while (file.good())
			{
				getline(file, line);
				content += '\n';
				content += line;
			}

			oss << endl << "source file " << source << " read okay";
			source = content;
		}
	}

	void Route::addCurrPosition(GPXP::Position &currentPos, std::string &name)
	{
		// Function to add the current position
		positions.push_back(currentPos);
		positionNames.push_back(name);
		oss << endl << "start position added: " << currentPos.toString();
	}

	void Route::addNextPosition(GPXP::Position &currentPos, GPXP::Position &nextPos, std::string &name)
	{
		// Function to add the next position
		if (distanceBetween(currentPos, nextPos) < granularity)
		{
			oss << endl << "position ignored: " << nextPos.toString();
		}

		else
		{
			positions.push_back(nextPos);
			positionNames.push_back(name);
			oss << endl << "position added: " << nextPos.toString();
			currentPos = nextPos;
		}
	}
	string * Route::setElementSet(string source, string tag){
		static string  sets []={"wwww","wwww","wwww""wwww"};
		string temp = XML_Parser::getAndEraseElement(source,tag);
		sets[0] = XML_Parser::getElementAttribute(temp, "lat");
		sets[1] = XML_Parser::getElementAttribute(temp, "lon");
   	    sets[2]= XML_Parser::getElementContent(XML_Parser::getElement(temp, "ele"));

/*

   	 string temp = getAndEraseElement(source, "rtept");
   	 		string lat = getElementAttribute(temp, "lat");
   	 		string lon = getElementAttribute(temp, "lon");
   	 		string ele = getElementContent(getElement(temp, "ele"));
*/


		/*string lat = XML_Parser::getElementAttribute(temp, "lat");
		string lon = XML_Parser::getElementAttribute(temp, "lon");
		string ele = XML_Parser::getElementContent(XML_Parser::getElement(temp, "ele"));*/

		return sets;

	}


}
